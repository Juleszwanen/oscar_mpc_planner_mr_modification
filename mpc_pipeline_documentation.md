# MPC Pipeline Documentation

## Table of Contents
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Pipeline Phases](#pipeline-phases)
4. [Module System](#module-system)
5. [Data Flow](#data-flow)
6. [Key Components](#key-components)
7. [Execution Flow](#execution-flow)
8. [Solver Generation Process](#solver-generation-process)
9. [Runtime Optimization Loop](#runtime-optimization-loop)
10. [Customization Guide](#customization-guide)

---

## Overview

The MPC (Model Predictive Control) planner implements a modular, robot-agnostic motion planning framework for mobile robots navigating in 2D dynamic environments. The system is designed to be:

- **Modular**: Cost and constraint components can be stacked to build complex behaviors
- **Robot Agnostic**: Core planning logic is separated from robot-specific implementations
- **ROS/ROS2 Compatible**: Supports both ROS versions through abstraction layers
- **Computationally Efficient**: Achieves 20-30 Hz real-time control with obstacle avoidance

The pipeline consists of two main phases:
1. **Offline Phase**: Solver generation (Python → C++ code generation)
2. **Online Phase**: Real-time planning and control (C++ execution)

---

## Architecture

The MPC planner architecture consists of the following layers:

```
┌─────────────────────────────────────────────────────────────┐
│                    ROS/ROS2 Interface Layer                  │
│              (mpc_planner_<system>/src/*.cpp)                │
│  • State callbacks                                           │
│  • Goal/path callbacks                                       │
│  • Obstacle callbacks                                        │
│  • Command publishing                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────┐
│                     Planner Core Layer                       │
│                  (mpc_planner/src/planner.cpp)               │
│  • Main control loop (solveMPC)                              │
│  • Module orchestration                                      │
│  • Data validation                                           │
│  • Warmstart management                                      │
└──────────────────────────┬──────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────┐
│                      Module Layer                            │
│            (mpc_planner_modules/src/*.cpp)                   │
│  • MPCBaseModule: Input penalization                         │
│  • ContouringModule: Path tracking                           │
│  • GoalModule: Goal tracking                                 │
│  • EllipsoidConstraintModule: Obstacle avoidance             │
│  • GuidanceConstraintModule: T-MPC parallelization           │
│  • ScenarioConstraintModule: SH-MPC uncertainty handling     │
│  • And more...                                               │
└──────────────────────────┬──────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────┐
│                     Solver Interface                         │
│          (mpc_planner_solver/src/solver_interface.cpp)       │
│  • Parameter management                                      │
│  • Warmstart handling                                        │
│  • Solver invocation (Forces Pro / Acados)                   │
│  • Solution retrieval                                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────┐
│                  Generated Solver Code                       │
│              (<system>_solver_autogenerated/)                │
│  • Optimization problem formulation                          │
│  • Constraints and costs                                     │
│  • Numerical solver (Forces Pro / Acados)                    │
└─────────────────────────────────────────────────────────────┘
```

---

## Pipeline Phases

### Phase 1: Offline Solver Generation

**Purpose**: Convert high-level MPC problem definition (Python) into optimized C++ solver code.

**Input**: 
- Module configuration (`mpc_planner_<system>/scripts/generate_<system>_solver.py`)
- Dynamic model definition (`solver_generator/solver_model.py`)
- Settings (`mpc_planner_<system>/config/settings.yaml`)

**Output**:
- Generated solver code (C++)
- Module interface files
- Parameter definitions
- CMake and package configuration

**Location**: `solver_generator/`

### Phase 2: Online Real-Time Planning

**Purpose**: Execute the generated solver in a closed-loop control system.

**Input**:
- Current robot state (position, velocity, orientation)
- Dynamic obstacles (positions, velocities, predictions)
- Reference path or goal
- Static obstacles (via decomp_util)

**Output**:
- Optimal trajectory
- Control commands (linear velocity, angular velocity)
- Success flag

**Location**: `mpc_planner/`, `mpc_planner_<system>/`

---

## Module System

### What is a Module?

A **module** is a self-contained component that contributes to the MPC optimization problem. Modules can add:
- **Objective terms** (costs to minimize)
- **Constraints** (inequality/equality constraints)
- **Custom optimization logic**

### Module Lifecycle

```
┌────────────────────────────────────────────────────────────┐
│                    Module Definition (Python)               │
│  File: mpc_planner_modules/scripts/<module_name>.py        │
│  • Define objectives (cost functions)                       │
│  • Define constraints                                       │
│  • Specify dependencies                                     │
│  • Define parameters                                        │
└───────────────────────┬────────────────────────────────────┘
                        │
                        │ Solver Generation
                        ▼
┌────────────────────────────────────────────────────────────┐
│              Module Implementation (C++)                    │
│  File: mpc_planner_modules/src/<module_name>.cpp           │
│  Header: mpc_planner_modules/include/.../module_name>.h    │
│                                                             │
│  Key Methods:                                               │
│  • update(): Pre-computation before optimization            │
│  • setParameters(): Set solver parameters for each step k   │
│  • visualize(): RViz visualization                          │
│  • isDataReady(): Check if required data is available       │
│  • onDataReceived(): React to new data                      │
│  • optimize(): Custom optimization (optional)               │
└───────────────────────┬────────────────────────────────────┘
                        │
                        │ Runtime Execution
                        ▼
┌────────────────────────────────────────────────────────────┐
│                  Module Execution (Runtime)                 │
│  1. isDataReady() - Check data availability                 │
│  2. update() - Compute module-specific data                 │
│  3. setParameters() - Set solver params for each horizon k  │
│  4. optimize() - Execute solver (or custom optimization)    │
│  5. visualize() - Display results in RViz                   │
└────────────────────────────────────────────────────────────┘
```

### Module Types

#### 1. Objective Modules
Add cost terms to minimize:
- **MPCBaseModule**: Penalize control inputs (acceleration, angular velocity)
- **ContouringModule**: Track a reference path (MPCC)
- **GoalModule**: Track a goal position
- **PathReferenceVelocityModule**: Track velocity profile along path
- **CurvatureAwareContouring**: Adjust velocity based on path curvature

#### 2. Constraint Modules
Add safety constraints:
- **EllipsoidConstraintModule**: Deterministic obstacle avoidance
- **LinearizedConstraintModule**: Linearized obstacle constraints
- **GaussianConstraintModule**: Chance-constrained obstacle avoidance
- **DecompConstraintModule**: Static obstacle avoidance
- **GuidanceConstraintModule**: T-MPC guidance wrapper
- **ScenarioConstraintModule**: SH-MPC scenario-based constraints

---

## Data Flow

### Input Data Flow

```
External Sources → ROS Callbacks → RealTimeData → Modules → Solver Parameters
```

#### 1. External Sources
- **State**: Robot odometry from `/input/state`
- **Goal**: User-clicked goal from `/input/goal`
- **Reference Path**: Global planner path from `/input/reference_path`
- **Obstacles**: Dynamic obstacles from `/input/obstacles`

#### 2. ROS Callbacks
Located in `mpc_planner_<system>/src/*.cpp`:
- `stateCallback()`: Updates `State` object
- `goalCallback()`: Updates goal in `RealTimeData`
- `pathCallback()`: Updates reference path
- `obstacleCallback()`: Updates dynamic obstacles

#### 3. RealTimeData Structure
Defined in `mpc_planner_types/include/mpc_planner_types/realtime_data.h`:
```cpp
struct RealTimeData {
    // Timing
    std::chrono::time_point<std::chrono::system_clock> planning_start_time;
    
    // Reference
    ReferencePath reference_path;
    Eigen::Vector2d goal;
    
    // Obstacles
    std::vector<DynamicObstacle> dynamic_obstacles;
    
    // Robot
    std::vector<Disc> robot_area;
    
    // Module-specific data
    // ... (added by modules)
};
```

#### 4. ModuleData Structure
Shared data between modules during one planning cycle:
```cpp
struct ModuleData {
    // Guidance constraints (T-MPC)
    std::vector<std::vector<GuidancePoint>> guidance_trajectories;
    int selected_trajectory;
    
    // Scenario constraints (SH-MPC)
    // ...
    
    // Any module can add data here
};
```

### Output Data Flow

```
Solver Solution → PlannerOutput → Control Commands → Robot
```

#### 1. Solver Solution
- State trajectory: `[x, y, psi, v, ...]` for steps `k = 0...N`
- Input trajectory: `[a, w, ...]` for steps `k = 0...N-1`

#### 2. PlannerOutput
```cpp
struct PlannerOutput {
    Trajectory trajectory;    // Planned trajectory
    bool success;            // Optimization success flag
};
```

#### 3. Control Commands
Published to `/output/command`:
```cpp
geometry_msgs::Twist cmd;
cmd.linear.x = planner->getSolution(1, "v");  // Velocity at k=1
cmd.angular.z = planner->getSolution(0, "w"); // Angular velocity at k=0
```

---

## Key Components

### 1. Planner Core (`mpc_planner/src/planner.cpp`)

**Responsibilities**:
- Orchestrate the entire planning cycle
- Validate input data
- Call module lifecycle methods
- Manage warmstart
- Invoke solver
- Return optimal trajectory

**Main Method**: `PlannerOutput solveMPC(State &state, RealTimeData &data)`

**Execution Steps**:
1. **Data Validation**: Check if all modules have required data
2. **Warmstart Initialization**: Use previous solution as initial guess
3. **Module Update**: Call `update()` on all modules
4. **Parameter Setting**: Call `setParameters()` for each horizon step k
5. **Optimization**: Call `optimize()` (solver or custom)
6. **Solution Extraction**: Extract trajectory from solver output
7. **Return**: Return `PlannerOutput` with success flag

### 2. Solver Interface (`mpc_planner_solver/src/solver_interface.cpp`)

**Responsibilities**:
- Wrap the generated solver (Forces Pro / Acados)
- Manage solver parameters and variables
- Handle warmstart data
- Provide solution access

**Key Methods**:
- `setXinit()`: Set initial state
- `setParameter()`: Set parameter value for step k
- `solve()`: Execute optimization
- `getOutput()`: Get solution variable value
- `initializeWarmstart()`: Set initial guess from previous solution

### 3. Module Manager (`solver_generator/control_modules.py`)

**Responsibilities**:
- Manage module collection during solver generation
- Combine objectives and constraints from all modules
- Generate C++ interface code

**Key Methods**:
- `add_module()`: Add a module to the manager
- `inequality_constraints()`: Collect all constraints
- Code generation methods

### 4. Dynamic Model (`solver_generator/solver_model.py`)

**Responsibilities**:
- Define robot dynamics
- Specify state and input variables
- Define variable bounds

**Example Models**:
- `ContouringSecondOrderUnicycleModel`: Bicycle model with contouring
- `ContouringPointMassModel`: Point mass model
- `ContouringSecondOrderUnicycleModelWithSlack`: Unicycle with slack variables

---

## Execution Flow

### Complete Execution Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                         START                                │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│              ROS Node Initialization                         │
│  • Load configuration (settings.yaml)                        │
│  • Create Planner object                                     │
│  • Initialize subscribers/publishers                         │
│  • Start timer at control_frequency                          │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        │ Timer Event
                        ▼
┌─────────────────────────────────────────────────────────────┐
│                    Control Loop Entry                        │
│  • Check timeout / objective reached                         │
│  • Mark planning start time                                  │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│               Planner::solveMPC(state, data)                 │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                  Data Readiness Check                        │
│  For each module:                                            │
│    • module->isDataReady(data, missing_data)                 │
│  If data missing → Return failure                            │
└───────────────────────┬─────────────────────────────────────┘
                        │ All data ready
                        ▼
┌─────────────────────────────────────────────────────────────┐
│               Warmstart Initialization                       │
│  If previous solution was feasible:                          │
│    • solver->initializeWarmstart(state, shift_forward)       │
│  Else:                                                       │
│    • solver->initializeWithBraking(state)                    │
│  • solver->setXinit(state)                                   │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                   Module Update Phase                        │
│  For each module:                                            │
│    • module->update(state, data, module_data)                │
│                                                              │
│  Examples:                                                   │
│  • ContouringModule: Find nearest point on path              │
│  • GuidanceConstraintModule: Generate guidance trajectories  │
│  • EllipsoidConstraintModule: Compute obstacle constraints   │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│              Parameter Setting Phase                         │
│  For k = 0 to N-1:                                           │
│    For each module:                                          │
│      • module->setParameters(data, module_data, k)           │
│                                                              │
│  Examples:                                                   │
│  • Set path points for contouring                            │
│  • Set obstacle positions and sizes                          │
│  • Set guidance points                                       │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                 Load Warmstart to Solver                     │
│  • solver->loadWarmstart()                                   │
│  • Set solver timeout based on remaining time                │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                   Optimization Phase                         │
│  For each module:                                            │
│    • exit_flag = module->optimize(state, data, module_data)  │
│    • If exit_flag != NOT_OPTIMIZED_YET: break                │
│                                                              │
│  If no custom optimization:                                  │
│    • exit_flag = solver->solve()                             │
│                                                              │
│  (Most modules don't override optimize, except T-MPC)        │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│              Check Optimization Success                      │
│  If exit_flag != 1:                                          │
│    • output.success = false                                  │
│    • Return empty PlannerOutput                              │
└───────────────────────┬─────────────────────────────────────┘
                        │ Success
                        ▼
┌─────────────────────────────────────────────────────────────┐
│                 Extract Solution                             │
│  For k = 1 to N-1:                                           │
│    • output.trajectory.add(                                  │
│        solver->getOutput(k, "x"),                            │
│        solver->getOutput(k, "y"),                            │
│        solver->getOutput(k, "psi"))                          │
│  • output.success = true                                     │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                  Return to Control Loop                      │
│  • Retrieve control commands:                                │
│    cmd.linear.x = solver->getOutput(1, "v")                  │
│    cmd.angular.z = solver->getOutput(0, "w")                 │
│  • Publish commands                                          │
│  • Visualize results                                         │
│  • Save data (if recording enabled)                          │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        │ Wait for next timer event
                        │
                        └──────────────┐
                                       │
                        ┌──────────────┘
                        │
                        ▼
```

---

## Solver Generation Process

### Overview

The solver generation process converts a high-level Python MPC problem definition into optimized C++ code that can be compiled and executed in real-time.

### Step-by-Step Process

#### 1. Configuration
**File**: `mpc_planner_<system>/scripts/generate_<system>_solver.py`

Define the MPC problem:
```python
settings = load_settings()  # Load config/settings.yaml

modules = ModuleManager()
model = ContouringSecondOrderUnicycleModel()  # Define dynamics

# Add modules
base_module = modules.add_module(MPCBaseModule(settings))
base_module.weigh_variable(var_name="a", weight_names="acceleration")
modules.add_module(ContouringModule(settings))
modules.add_module(GuidanceConstraintModule(settings, 
                   constraint_submodule=EllipsoidConstraintModule))

generate_solver(modules, model, settings)  # Generate!
```

#### 2. Module Collection
**File**: `solver_generator/control_modules.py`

The `ModuleManager` collects:
- Objective terms from each module
- Constraint terms from each module
- Parameter definitions
- Dependencies

#### 3. Problem Formulation
**File**: `solver_generator/generate_forces_solver.py` or `generate_acados_solver.py`

Builds the optimization problem:
```
minimize:    Σ_k [objective_terms(k)]
subject to:  dynamics(x_k, u_k) = x_{k+1}
             constraints(x_k, u_k, params_k) <= 0
             x_min <= x_k <= x_max
             u_min <= u_k <= u_max
```

#### 4. Code Generation
**Files**: `solver_generator/generate_cpp_files.py`

Generates:
- **Solver wrapper** (`mpc_planner_solver/include/solver_interface.h`)
- **Module interface** (`mpc_planner_modules/include/modules.h`)
- **Parameter maps** (mapping parameter names to indices)
- **CMake files** (build configuration)
- **RQT reconfigure** (dynamic parameter tuning)

#### 5. Solver Compilation
The generated C++ code is compiled with the ROS workspace:
```bash
catkin build mpc_planner_<system>
```

### Generated Files Structure

```
mpc_planner_solver/
├── include/
│   └── solver_interface.h          # Solver C++ interface
├── src/
│   └── solver_interface.cpp        # Solver implementation
└── <system>_solver_autogenerated/  # Generated solver code
    ├── solver.c / solver.cpp       # Main solver
    ├── interface/                  # Solver interface
    └── forces_pro / acados/        # Solver-specific files

mpc_planner_modules/
├── include/
│   └── modules.h                   # Auto-generated module includes
└── scripts/
    ├── parameter_map.yaml          # Parameter name → index mapping
    └── state_map.yaml              # State/input name → index mapping
```

---

## Runtime Optimization Loop

### The Core MPC Loop

At each control iteration (typically 20-30 Hz), the following happens:

#### 1. State Update (0.1-0.5 ms)
- Receive robot odometry
- Update internal state representation

#### 2. Data Update (0.5-2 ms)
- Receive obstacle detections
- Update obstacle predictions
- Receive reference path/goal

#### 3. Planning Call (30-50 ms total)

**a. Data Validation (0.1 ms)**
- Check all required data is available
- Return failure if data is missing

**b. Warmstart (0.5 ms)**
- Use previous solution as initial guess
- Shift solution forward in time if enabled

**c. Module Update (5-15 ms)**
- Each module computes its data
- Example: Guidance module generates guidance trajectories

**d. Parameter Setting (2-5 ms)**
- Set solver parameters for each horizon step
- Example: Obstacle positions, path points

**e. Optimization (20-40 ms)**
- Solve nonlinear program (NLP)
- Find optimal control inputs

**f. Solution Extraction (0.5 ms)**
- Extract optimal trajectory
- Check for bound violations

#### 4. Control Application (0.1 ms)
- Extract control command (velocity, angular velocity)
- Publish to robot

#### 5. Visualization (2-5 ms)
- Publish trajectory markers
- Publish obstacle visualizations
- Update RViz displays

### Performance Considerations

**Typical Timing Budget** (50 Hz = 20 ms period):
- Planning: 15 ms
- Visualization: 2 ms
- Buffer: 3 ms

**Strategies for Meeting Real-Time Requirements**:
1. **Warmstart**: Provide good initial guess from previous solution
2. **Early Termination**: Set solver timeout to meet deadline
3. **Horizon Length**: Shorter horizon = faster solve (but worse performance)
4. **Simplified Constraints**: Use linearized instead of nonlinear constraints
5. **Parallel Optimization**: T-MPC runs multiple planners in parallel

---

## Customization Guide

### Adding a Custom Module

To add your own MPC module, follow these steps:

#### Step 1: Define Module in Python
**File**: `mpc_planner_modules/scripts/my_custom_module.py`

```python
from control_modules import Module

class MyCustomModule(Module):
    def __init__(self, settings):
        super().__init__()
        self.module_name = "MyCustomModule"  # C++ class name
        self.description = "My custom MPC module"
        
        # Add parameters
        settings["params"].add_parameter("my_param", length=N)
        
        # Add objectives
        self.objectives = []
        # self.objectives.append(MyObjective(...))
        
        # Add constraints
        self.constraints = []
        # self.constraints.append(MyConstraint(...))
```

#### Step 2: Implement Module in C++
**File**: `mpc_planner_modules/include/mpc_planner_modules/my_custom_module.h`

```cpp
#ifndef MY_CUSTOM_MODULE_H
#define MY_CUSTOM_MODULE_H

#include <mpc_planner_modules/controller_module.h>

namespace MPCPlanner {

class MyCustomModule : public ControllerModule {
public:
    MyCustomModule(std::shared_ptr<Solver> solver);
    
    void update(State &state, const RealTimeData &data, 
                ModuleData &module_data) override;
    
    void setParameters(const RealTimeData &data, 
                       const ModuleData &module_data, int k) override;
    
    void visualize(const RealTimeData &data, 
                   const ModuleData &module_data) override;
};

} // namespace MPCPlanner

#endif
```

**File**: `mpc_planner_modules/src/my_custom_module.cpp`

```cpp
#include <mpc_planner_modules/my_custom_module.h>

namespace MPCPlanner {

MyCustomModule::MyCustomModule(std::shared_ptr<Solver> solver)
    : ControllerModule(ModuleType::OBJECTIVE, solver, "MyCustomModule") {}

void MyCustomModule::update(State &state, const RealTimeData &data, 
                            ModuleData &module_data) {
    // Compute module-specific data
    // This runs once per planning cycle
}

void MyCustomModule::setParameters(const RealTimeData &data, 
                                   const ModuleData &module_data, int k) {
    // Set solver parameters for step k
    _solver->setParameter(k, "my_param", computed_value);
}

void MyCustomModule::visualize(const RealTimeData &data, 
                               const ModuleData &module_data) {
    // Publish RViz markers
}

} // namespace MPCPlanner
```

#### Step 3: Register Module
**File**: `mpc_planner_modules/src/register_modules.cpp` (or in module .cpp)

```cpp
#include <mpc_planner_modules/my_custom_module.h>

// In initializeModules function:
modules.push_back(std::make_shared<MyCustomModule>(solver));
```

#### Step 4: Use in Solver Generation
**File**: `mpc_planner_<system>/scripts/generate_<system>_solver.py`

```python
from my_custom_module import MyCustomModule

# In configuration function:
modules.add_module(MyCustomModule(settings))
```

#### Step 5: Generate and Build
```bash
poetry run python mpc_planner_<system>/scripts/generate_<system>_solver.py
catkin build mpc_planner_<system>
```

### Creating a Custom System

To use the planner on a new robot system:

#### 1. Create System Package
```bash
cd ws/src
catkin_create_pkg mpc_planner_mysystem roscpp mpc_planner mpc_planner_modules ...
```

#### 2. Define Solver Generation Script
**File**: `mpc_planner_mysystem/scripts/generate_mysystem_solver.py`

Copy from `mpc_planner_jackal` or `mpc_planner_jackalsimulator` and adapt.

#### 3. Create Configuration
**File**: `mpc_planner_mysystem/config/settings.yaml`

Copy from another system and adjust:
- `name: mysystem`
- `N`: Horizon length
- `integrator_step`: Time step
- `robot`: Robot dimensions
- Module weights

#### 4. Implement ROS Interface
**Files**: 
- `mpc_planner_mysystem/src/ros1_mysystem.cpp` (or `ros2_mysystem.cpp`)
- `mpc_planner_mysystem/include/mpc_planner_mysystem/ros1_mysystem.h`

Key components:
- State callback: Update `State` from odometry
- Goal callback: Update goal in `RealTimeData`
- Path callback: Update reference path
- Obstacle callback: Update obstacles
- Control loop: Call `planner->solveMPC()` and publish commands

#### 5. Create Launch File
**File**: `mpc_planner_mysystem/launch/ros1_mysystem.launch`

Define:
- Node parameters
- Topic remappings
- RViz configuration

#### 6. Generate Solver and Build
```bash
poetry run python mpc_planner_mysystem/scripts/generate_mysystem_solver.py
catkin build mpc_planner_mysystem
```

---

## Advanced Topics

### T-MPC: Topology-Driven MPC

**Concept**: Compute multiple distinct trajectories in parallel, each passing obstacles differently.

**Implementation**: `GuidanceConstraintModule`
- Wraps any constraint module (e.g., `EllipsoidConstraintModule`)
- Generates guidance trajectories using the guidance planner
- Runs multiple MPC problems in parallel, one per guidance
- Selects the best trajectory based on cost

**Key Files**:
- `mpc_planner_modules/src/guidance_constraints.cpp`
- `guidance_planner` package (external dependency)

### SH-MPC: Safe Horizon MPC

**Concept**: Handle non-Gaussian uncertainty in obstacle motion predictions.

**Implementation**: `ScenarioConstraintModule`
- Samples multiple scenarios from obstacle prediction distribution
- Enforces constraints for all scenarios simultaneously
- Guarantees bounded probability of collision

**Key Files**:
- `mpc_planner_modules/src/scenario_constraints.cpp`
- `scenario_module` package (external dependency)

### Static Obstacle Avoidance

**Concept**: Avoid static obstacles using convex decomposition.

**Implementation**: `DecompConstraintModule`
- Uses `decomp_util` to compute safe corridors
- Adds linear constraints to keep robot in free space

**Key Files**:
- `mpc_planner_modules/src/decomp_constraints.cpp`
- `DecompUtil` package (external dependency)

---

## Debugging and Troubleshooting

### Common Issues

#### 1. Solver Not Found
**Error**: `Solver not found` during generation

**Solution**: 
- Check `settings.yaml`: `solver_settings/solver` must be `forces` or `acados`
- Ensure solver is installed and in `PYTHONPATH` (Forces) or `LD_LIBRARY_PATH` (Acados)

#### 2. Infeasible Optimization
**Symptom**: `output.success = false`, robot brakes

**Causes**:
- Conflicting constraints (e.g., obstacle too close to path)
- Invalid warmstart
- Too short horizon

**Solutions**:
- Increase horizon length (`N`)
- Increase obstacle safety margin
- Enable slack variables for soft constraints
- Check warmstart initialization

#### 3. Real-Time Performance Issues
**Symptom**: Solver timeout, low control frequency

**Solutions**:
- Reduce horizon length (`N`)
- Reduce number of obstacles (`max_obstacles`)
- Use simpler constraints (linearized instead of ellipsoidal)
- Disable parallel scenarios (if using SH-MPC)
- Adjust solver tolerance settings

#### 4. Module Data Not Ready
**Symptom**: "Data is not ready, missing ..." warning

**Causes**:
- Missing topic subscription
- Topic not publishing
- Module `isDataReady()` returns false

**Solutions**:
- Check topic connections: `rostopic list`, `rostopic echo`
- Verify publishers are running
- Check module's `isDataReady()` implementation

### Debugging Tools

#### Enable Debug Output
In `settings.yaml`:
```yaml
debug_output: true
debug_visuals: true
debug_limits: true
```

#### RQT Reconfigure
Tune parameters online:
```bash
rosrun rqt_reconfigure rqt_reconfigure
```

#### Data Recording
Enable in `settings.yaml`:
```yaml
recording:
  enable: true
  folder: "~/.ros/mpc_planner_data"
  file: "experiment_data"
```

#### Profiling
The planner includes built-in benchmarking:
- Planning time
- Optimization time
- Update time
- Per-module timing

Results are printed on shutdown.

---

## References

### Key Papers

1. **T-MPC++**: O. de Groot et al., "Topology-Driven Parallel Trajectory Optimization in Dynamic Environments," IEEE T-RO, 2024.
2. **SH-MPC**: O. de Groot et al., "Scenario-Based Trajectory Optimization with Bounded Probability of Collision," IJRR, 2024.
3. **MPCC**: J. Ziegler et al., "Model Predictive Contouring Control," IEEE T-IV, 2019.

### External Dependencies

- **Forces Pro**: https://www.embotech.com/softwareproducts/forcespro/
- **Acados**: https://docs.acados.org/
- **guidance_planner**: https://github.com/tud-amr/guidance_planner
- **scenario_module**: https://github.com/oscardegroot/scenario_module
- **decomp_util**: https://github.com/oscardegroot/DecompUtil
- **pedestrian_simulator**: https://github.com/oscardegroot/pedestrian_simulator

### Repository Structure

```
mpc_planner/                        # Core planner logic
mpc_planner_modules/                # Objective and constraint modules
mpc_planner_solver/                 # Solver interface
mpc_planner_types/                  # Data structures
mpc_planner_util/                   # Utilities (logging, math, etc.)
mpc_planner_msgs/                   # ROS messages
solver_generator/                   # Python solver generation
mpc_planner_<system>/               # System-specific implementations
  ├── src/                          # ROS interface
  ├── config/                       # Configuration files
  ├── scripts/                      # Solver generation scripts
  └── launch/                       # ROS launch files
```

---

## Conclusion

The MPC planner pipeline is a sophisticated, modular system that enables efficient real-time motion planning for mobile robots. Understanding the flow from solver generation to runtime optimization is key to effectively using and extending the system.

Key takeaways:
- **Modularity** enables flexible problem composition
- **Separation of concerns** between solver generation (Python) and runtime (C++)
- **Performance** is achieved through warmstart, efficient code generation, and careful timing management
- **Extensibility** is facilitated by the module system and clear interfaces

For more examples and detailed implementation, refer to the codebase and the provided paper references.
