#include <mpc_planner/planner.h>

#include <mpc_planner/experiment_util.h>

/** @note: Autogenerated */
#include <mpc_planner_modules/modules.h>

#include <mpc_planner_types/realtime_data.h>
#include <mpc_planner_solver/solver_interface.h>

#include <mpc_planner_util/load_yaml.hpp>
#include <mpc_planner_util/parameters.h>
#include <mpc_planner_util/data_visualization.h>

#include <ros_tools/profiling.h>
#include <ros_tools/logging.h>
#include <ros_tools/visuals.h>
#include <ros_tools/data_saver.h>

#include <sstream>
#include <iomanip>

namespace MPCPlanner
{

    Planner::Planner()
    {
        // Initialize the solver
        _solver = std::make_shared<Solver>();
        _solver->reset();

        initializeModules(_modules, _solver);

        _experiment_util = std::make_shared<ExperimentUtil>();

        _startup_timer = std::make_unique<RosTools::Timer>(1.0); // Give some time to receive data
    }

    Planner::Planner(std::string ego_robot_ns, bool safe_extra_data) : _ego_robot_ns(ego_robot_ns), _safe_extra_data(safe_extra_data)
    {
        // Initialize the solver
        _solver = std::make_shared<Solver>();
        _solver->reset();

        initializeModules(_modules, _solver);

        _experiment_util = std::make_shared<ExperimentUtil>();

        _startup_timer = std::make_unique<RosTools::Timer>(1.0); // Give some time to receive data

        LOG_INFO("CREATED THE MPCPlanner for " + _ego_robot_ns);

        setEgoNameSpaceGuidanceModule(_ego_robot_ns);
    }

    bool Planner::setEgoNameSpaceGuidanceModule(const std::string &ego_robot_ns)
    {
        bool found = false;
        for (auto &module : _modules)
        {
            // Try to cast the module to GuidanceConstraints
            auto *guidance_module = dynamic_cast<GuidanceConstraints *>(module.get());

            if (guidance_module != nullptr)
            {
                // Successfully cast - this is a GuidanceConstraints module
                guidance_module->_ego_robot_ns = ego_robot_ns;
                found = true;
                LOG_INFO("Set ego namespace to '" + ego_robot_ns + "' in GuidanceConstraints module");
                break; // Assuming only one GuidanceConstraints module exists
            }
        }

        if (!found)
        {
            LOG_WARN("GuidanceConstraints module not found in planner modules");
        }

        return found;
    }

    // Given real-time data, solve the MPC problem
    PlannerOutput Planner::solveMPC(State &state, RealTimeData &data)
    {
        LOG_MARK("Planner::solveMPC");
        bool was_feasible = _output.success;
        /** @note Jules: This is added by you to keep track of the previously selected topology */
        const int prev_followed_topology = _output.selected_topology_id; // -1 is the default topology

        // Jules: Here we override the old _output data with a new one
        _output = PlannerOutput(_solver->dt, _solver->N);

        _module_data = ModuleData(); // Reset module data

        // Check if all modules have enough data
        _is_data_ready = true;
        std::string missing_data;
        for (auto &module : _modules)
            _is_data_ready = _is_data_ready & module->isDataReady(data, missing_data);

        if (!_is_data_ready)
        {
            if (_startup_timer->hasFinished())
                LOG_WARN_THROTTLE(3000, "Data is not ready, missing " + missing_data + "\b");

            _output.success = false;
            return _output;
        }
        else if (_was_reset)
        {
            _experiment_util->setStartExperiment();
            _was_reset = false;
        }

        LOG_MARK("Data checked");

        int exit_flag;
        {
            PROFILE_SCOPE("Planning");

            auto &planning_benchmarker = BENCHMARKERS.getBenchmarker("planning");
            if (planning_benchmarker.isRunning())
                planning_benchmarker.cancel();

            planning_benchmarker.start();

            // Set the initial guess
            bool shift_forward = CONFIG["shift_previous_solution_forward"].as<bool>() &&
                                 CONFIG["enable_output"].as<bool>();
            if (was_feasible)
                _solver->initializeWarmstart(state, shift_forward);
            else
            {
                // _solver->initializeWithState(state);
                _solver->initializeWithBraking(state);
            }

            _solver->setXinit(state); // Set the initial state

            // Update all modules
            {
                LOG_MARK("Updating modules");
                PROFILE_SCOPE("Update");

                for (auto &module : _modules)
                    module->update(state, data, _module_data);
            }

            {
                LOG_MARK("Setting parameters");
                PROFILE_SCOPE("SetParameters");
                for (int k = 0; k < _solver->N; k++)
                {
                    for (auto &module : _modules)
                    {
                        module->setParameters(data, _module_data, k);
                    }
                }
            }

            _warmstart = Trajectory();
            for (int k = 0; k < _solver->N; k++)
                _warmstart.add(_solver->getEgoPrediction(k, "x"), _solver->getEgoPrediction(k, "y"));

            _solver->loadWarmstart();

            std::chrono::duration<double> used_time = std::chrono::system_clock::now() - data.planning_start_time;
            _solver->_params.solver_timeout = 1. / CONFIG["control_frequency"].as<double>() - used_time.count() - 0.006;

            // Solve MPC
            LOG_MARK("Solve optimization");
            {
                PROFILE_SCOPE("Optimization");
                BENCHMARKERS.getBenchmarker("optimization").start();
                exit_flag = EXIT_CODE_NOT_OPTIMIZED_YET;
                for (auto &module : _modules)
                {
                    exit_flag = module->optimize(state, data, _module_data);
                    if (exit_flag != EXIT_CODE_NOT_OPTIMIZED_YET)
                        break;
                }
                // When no module provides costum optimization or something unexpected happens when there is a module with an optimiza module
                // it's the default optimization strategy when no module (/can claim) claims responsibility for solving the problem!
                if (exit_flag == EXIT_CODE_NOT_OPTIMIZED_YET)
                    // LOG_ERROR("_solver->solve() is called");
                    exit_flag = _solver->solve();
                BENCHMARKERS.getBenchmarker("optimization").stop();
            }

            planning_benchmarker.stop();
        }

        if (exit_flag != 1)
        {
            _output.success = false;
            LOG_WARN_THROTTLE(500, "MPC failed: " + _solver->explainExitFlag(exit_flag));
            // LOG_WARN("MPC failed: " + _solver->explainExitFlag(exit_flag)); // Deze weer verwijderen jules 29-09
            return _output; // Jules: Here we return an empty output
        }

        _output.success = true;
        /**  Jules @note Here we do from 1 and not from zero which is weird in my opinion   K WAS ORIGNIALLY 1 but now I SET IT TO 0) OCT 1*/
        for (int k = 0; k < _solver->N; k++)
        {
            _output.trajectory.add(_solver->getOutput(k, "x"), _solver->getOutput(k, "y"));
            _output.trajectory.add_orientation(_solver->getOutput(k, "psi")); // JULES dit heb jij toegevoed om ervoor te zorgen dat we de orientatie van elke punt in de trajectory ook hebben deze hebben we later nodig voor het passen van een traject asl obstacle
        }

        /** @note Jules: you added this to store the meta data of the guidance module
         * Remeber that for now the module data is reset in each iteration
         */
        if (CONFIG["JULES"]["use_extra_params_module_data"].as<bool>())
        {
            // ADD THIS: Transfer homology metadata
            _output.selected_topology_id = _module_data.selected_topology_id;
            _output.selected_planner_index = _module_data.selected_planner_index;
            _output.used_guidance = _module_data.used_guidance;
            _output.trajectory_cost = _module_data.trajectory_cost;
            _output.solver_exit_code = exit_flag;
            _output.following_new_topology = (prev_followed_topology == _module_data.selected_topology_id) ? false : true;
            _output.previous_topology_id = prev_followed_topology; // Add this line
        }

        if (_output.success && CONFIG["debug_limits"].as<bool>())
            _solver->printIfBoundLimited();

        LOG_MARK("Planner::solveMPC done");

        return _output;
    }

    double Planner::getSolution(int k, std::string &&var_name) const
    {
        return _solver->getOutput(k, std::forward<std::string>(var_name));
    }

    // Jules: Dont think this one is actually used
    RosTools::DataSaver &Planner::getDataSaver() const
    {
        return _experiment_util->getDataSaver();
    }

    void Planner::onDataReceived(RealTimeData &data, std::string &&data_name)
    {
        for (auto &module : _modules)
            module->onDataReceived(data, std::forward<std::string>(data_name));
    }

    // Visualize everything inside the planner
    void Planner::visualize(const State &state, const RealTimeData &data)
    {
        PROFILE_SCOPE("Planner::Visualize");
        LOG_MARK("Planner::visualize");
        (void)state;

        for (auto &module : _modules)

            module->visualize(data, _module_data);

        visualizeTrajectory(_output.trajectory, "planned_trajectory", true, 0.2);

        if (CONFIG["debug_visuals"].as<bool>())
            visualizeTrajectory(_warmstart, "warmstart_trajectory", true, 0.2);

        visualizeObstacles(data.dynamic_obstacles, "obstacles", true, 1.0);
        // visualizeObstaclePredictions(data.dynamic_obstacles, "obstacle_predictions", true); //JULES: YOU COMMENTED THIS OUT, on sep 11, because you publish the obstacle predictions a step ealier to see what the ego robto actually optimizes against. before generating a new path
        visualizeRobotArea(state.getPos(), state.get("psi"), data.robot_area, "robot_area", true);

        std::vector<double> angles;
        for (int k = 1; k < _solver->N; k++)
            angles.emplace_back(_solver->getOutput(k, "psi"));

        visualizeRectangularRobotArea(state.getPos(), state.get("psi"),
                                      CONFIG["robot"]["length"].as<double>(), CONFIG["robot"]["width"].as<double>(),
                                      "robot_rect_area", true);

        visualizeRobotAreaTrajectory(_output.trajectory, angles, data.robot_area, "robot_area_trajectory", true, 0.1);
        LOG_MARK("Planner::visualize Done");
    }

    /** @note Jules: Deze jij toegevoegd om meer controle te krijgen over wanneer dynamische obstacles worden gepublished */

    void Planner::visualizeObstaclePredictionsPlanner(const State &state, const RealTimeData &data, bool include_time)
    {
        if (!include_time)
        {
            visualizeObstaclePredictions(data.dynamic_obstacles, "obstacle_predictions", true, 0.8);
        }
        else
        {
            visualizeObstaclePredictionsWithTime(data.dynamic_obstacles, "obstacle_predictions", true, 0.8, _solver->dt);
        }
    }
    void Planner::saveData(State &state, RealTimeData &data)
    {
        if (!_is_data_ready)
            return;

        auto &data_saver = _experiment_util->getDataSaver();

        // Save planning data
        double planning_time = BENCHMARKERS.getBenchmarker("planning").getLast();
        data_saver.AddData("runtime_control_loop", planning_time);
        if (planning_time > 1. / CONFIG["control_frequency"].as<double>())
            LOG_WARN("Planning took too long: " << planning_time << " ms");
        data_saver.AddData("runtime_optimization", BENCHMARKERS.getBenchmarker("optimization").getLast());

        if (!_output.success)
            data_saver.AddData("status", 3.); // 3 and 2 for backward compatilibity
        else
            data_saver.AddData("status", 2.);

        for (auto &module : _modules)
            module->saveData(data_saver);

        // JULES: Save topology/homology metadata from PlannerOutput
        if (CONFIG["JULES"]["use_extra_params_module_data"].as<bool>())
        {
            data_saver.AddData("jules_selected_topology_id", _output.selected_topology_id);
            data_saver.AddData("jules_selected_planner_index", _output.selected_planner_index);
            data_saver.AddData("jules_used_guidance", _output.used_guidance ? 1.0 : 0.0);
            data_saver.AddData("jules_trajectory_cost", _output.trajectory_cost);
            data_saver.AddData("jules_solver_exit_code", static_cast<double>(_output.solver_exit_code));
            data_saver.AddData("jules_following_new_topology", _output.following_new_topology ? 1.0 : 0.0);
            data_saver.AddData("jules_previous_topology_id", _output.previous_topology_id);
            data_saver.AddData("jules_communicated_trajectory", data.communicated_trajectory ? 1.0 : 0.0);
        }

        _experiment_util->update(state, _solver, data);
    }

    void Planner::reset(State &state, RealTimeData &data, bool success)
    {
        if (CONFIG["recording"]["enable"].as<bool>())
            _experiment_util->onTaskComplete(success); // Save data

        _solver->reset(); // Reset the solver

        for (auto &module : _modules) // Reset modules
            module->reset();

        state = State(); // Reset the state
        data.reset();    // Reset the data

        /** @note Jules: you added this to reset the homology information */
        _output = PlannerOutput(); // Reset the ouput to defaults so mainly for resetting homology information
        _was_reset = true;
        _startup_timer->start();
    }

    bool Planner::isObjectiveReached(const State &state, const RealTimeData &data) const
    {
        bool objective_reached = true;
        for (auto &module : _modules)
            objective_reached = objective_reached && module->isObjectiveReached(state, data);
        return objective_reached;
    }
}

/** @note Jules: Deze heb jij toegevoegd om beter te kunnen zien wat de planner output */
std::string MPCPlanner::PlannerOutput::logOutput() const
{
    std::ostringstream oss;

    if (success && solver_exit_code == 1)
    {
        // Success case - log all details
        oss << "MPC Planning SUCCESS ✓\n"
            << "  Topology ID:     " << (selected_topology_id == -1 ? "N/A" : std::to_string(selected_topology_id)) << "\n"
            << "  Planner Index:   " << (selected_planner_index == -1 ? "N/A" : std::to_string(selected_planner_index)) << "\n"
            << "  Used Guidance:   " << (used_guidance ? "Yes" : "No (T-MPC++)") << "\n"
            << "  Trajectory Cost: " << std::fixed << std::setprecision(4) << trajectory_cost << "\n"
            << "  Topology Switch: " << (following_new_topology ? ("Yes (from " + (previous_topology_id == -1 ? "N/A" : std::to_string(previous_topology_id)) + " to " + (selected_topology_id == -1 ? "N/A" : std::to_string(selected_topology_id)) + ")") : "No") << "\n"
            << "  Solver Status:   SUCCESS (exit code: " << solver_exit_code << ")";
    }
    else
    {
        // Failure case - focus on failure reason
        oss << "MPC Planning FAILED ✗\n"
            << "  Solver Exit Code: " << solver_exit_code;

        // Decode exit code meaning
        switch (solver_exit_code)
        {
        case 1:
            oss << " (SUCCESS - but success flag is false)";
            break;
        case 0:
            oss << " (MAX_ITERATIONS_REACHED)";
            break;
        case -1:
            oss << " (INFEASIBLE)";
            break;
        default:
            oss << " (UNKNOWN_ERROR)";
            break;
        }

        oss << "\n  Success Flag:     " << (success ? "true" : "false");

        // Still show available metadata if present
        if (selected_topology_id != -1 || selected_planner_index != -1)
        {
            oss << "\n  Topology ID:      " << (selected_topology_id == -1 ? "N/A" : std::to_string(selected_topology_id))
                << "\n  Planner Index:    " << (selected_planner_index == -1 ? "N/A" : std::to_string(selected_planner_index));
        }
    }

    return oss.str();
}