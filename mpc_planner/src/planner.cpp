#include <mpc_planner/planner.h>

#include <mpc_planner/experiment_util.h>

/** @note: Autogenerated */
#include <mpc_planner_modules/modules.h>

#include <mpc_planner_types/realtime_data.h>
#include <mpc_planner_solver/solver_interface.h>

#include <mpc_planner_util/load_yaml.hpp>
#include <mpc_planner_util/parameters.h>
#include <mpc_planner_util/data_visualization.h>

#include <ros_tools/profiling.h>
#include <ros_tools/logging.h>
#include <ros_tools/visuals.h>
#include <ros_tools/data_saver.h>

namespace MPCPlanner
{

    Planner::Planner()
    {
        // Initialize the solver
        _solver = std::make_shared<Solver>();
        _solver->reset();

        initializeModules(_modules, _solver);

        _experiment_util = std::make_shared<ExperimentUtil>();

        _startup_timer = std::make_unique<RosTools::Timer>(1.0); // Give some time to receive data
    }

    // Given real-time data, solve the MPC problem
    PlannerOutput Planner::solveMPC(State &state, RealTimeData &data)
    {
        LOG_MARK("Planner::solveMPC");
        bool was_feasible = _output.success;
        _output = PlannerOutput(_solver->dt, _solver->N);

        _module_data = ModuleData(); // Reset module data

        // Check if all modules have enough data
        _is_data_ready = true;
        std::string missing_data;
        for (auto &module : _modules)
            _is_data_ready = _is_data_ready & module->isDataReady(data, missing_data);

        if (!_is_data_ready)
        {
            if (_startup_timer->hasFinished())
                LOG_WARN_THROTTLE(3000, "Data is not ready, missing " + missing_data + "\b");

            _output.success = false;
            return _output;
        }
        else if (_was_reset)
        {
            _experiment_util->setStartExperiment();
            _was_reset = false;
        }

        LOG_MARK("Data checked");

        int exit_flag;
        {
            PROFILE_SCOPE("Planning");

            auto &planning_benchmarker = BENCHMARKERS.getBenchmarker("planning");
            if (planning_benchmarker.isRunning())
                planning_benchmarker.cancel();

            planning_benchmarker.start();

            // Set the initial guess
            bool shift_forward = CONFIG["shift_previous_solution_forward"].as<bool>() &&
                                 CONFIG["enable_output"].as<bool>();
            if (was_feasible)
                _solver->initializeWarmstart(state, shift_forward);
            else
            {
                // _solver->initializeWithState(state);
                _solver->initializeWithBraking(state);
            }

            _solver->setXinit(state); // Set the initial state

            // Update all modules
            {
                LOG_MARK("Updating modules");
                PROFILE_SCOPE("Update");

                for (auto &module : _modules)
                    module->update(state, data, _module_data);
            }

            {
                LOG_MARK("Setting parameters");
                PROFILE_SCOPE("SetParameters");
                for (int k = 0; k < _solver->N; k++)
                {
                    for (auto &module : _modules)
                    {
                        module->setParameters(data, _module_data, k);
                    }
                }
            }

            _warmstart = Trajectory();
            for (int k = 0; k < _solver->N; k++)
                _warmstart.add(_solver->getEgoPrediction(k, "x"), _solver->getEgoPrediction(k, "y"));

            _solver->loadWarmstart();

            std::chrono::duration<double> used_time = std::chrono::system_clock::now() - data.planning_start_time;
            _solver->_params.solver_timeout = 1. / CONFIG["control_frequency"].as<double>() - used_time.count() - 0.006;

            // Solve MPC
            LOG_MARK("Solve optimization");
            {
                PROFILE_SCOPE("Optimization");
                BENCHMARKERS.getBenchmarker("optimization").start();
                exit_flag = EXIT_CODE_NOT_OPTIMIZED_YET;
                for (auto &module : _modules)
                {
                    exit_flag = module->optimize(state, data, _module_data);
                    if (exit_flag != EXIT_CODE_NOT_OPTIMIZED_YET)
                        break;
                }
                // When no module provides costum optimization or something unexpected happens when there is a module with an optimiza module
                // it's the default optimization strategy when no module (/can claim) claims responsibility for solving the problem!
                if (exit_flag == EXIT_CODE_NOT_OPTIMIZED_YET)
                    // LOG_ERROR("_solver->solve() is called");
                    exit_flag = _solver->solve();
                BENCHMARKERS.getBenchmarker("optimization").stop();
            }

            planning_benchmarker.stop();
        }

        if (exit_flag != 1)
        {
            _output.success = false;
            LOG_WARN_THROTTLE(500, "MPC failed: " + _solver->explainExitFlag(exit_flag));
            // LOG_WARN("MPC failed: " + _solver->explainExitFlag(exit_flag)); // Deze weer verwijderen jules 29-09
            return _output; // Jules: Here we return an empty output
        }

        _output.success = true;
        /* Jules @note Here we do from 1 and not from zero which is weird in my opinion   K WAS ORIGNIALLY 1 but now I SET IT TO 0) OCT 1*/
        for (int k = 0; k < _solver->N; k++)
        {
            _output.trajectory.add(_solver->getOutput(k, "x"), _solver->getOutput(k, "y"));
            _output.trajectory.add_orientation(_solver->getOutput(k, "psi")); // JULES dit heb jij toegevoed om ervoor te zorgen dat we de orientatie van elke punt in de trajectory ook hebben deze hebben we later nodig voor het passen van een traject asl obstacle
        }

        /* @note Jules: you added this to store the cost of the trajectory*/
        _output.trajectory_cost = _solver->_info.pobj;
        

        if (_output.success && CONFIG["debug_limits"].as<bool>())
            _solver->printIfBoundLimited();

        LOG_MARK("Planner::solveMPC done");

        return _output;
    }

    double Planner::getSolution(int k, std::string &&var_name) const
    {
        return _solver->getOutput(k, std::forward<std::string>(var_name));
    }

    RosTools::DataSaver &Planner::getDataSaver() const
    {
        return _experiment_util->getDataSaver();
    }

    void Planner::onDataReceived(RealTimeData &data, std::string &&data_name)
    {
        for (auto &module : _modules)
            module->onDataReceived(data, std::forward<std::string>(data_name));
    }

    // Visualize everything inside the planner
    void Planner::visualize(const State &state, const RealTimeData &data)
    {
        PROFILE_SCOPE("Planner::Visualize");
        LOG_MARK("Planner::visualize");
        (void)state;

        for (auto &module : _modules)
            module->visualize(data, _module_data);

        visualizeTrajectory(_output.trajectory, "planned_trajectory", true, 0.2);

        if (CONFIG["debug_visuals"].as<bool>())
            visualizeTrajectory(_warmstart, "warmstart_trajectory", true, 0.2);

        visualizeObstacles(data.dynamic_obstacles, "obstacles", true, 1.0);
        // visualizeObstaclePredictions(data.dynamic_obstacles, "obstacle_predictions", true); //JULES: YOU COMMENTED THIS OUT, on sep 11, because you publish the obstacle predictions a step ealier to see what the ego robto actually optimizes against. before generating a new path
        visualizeRobotArea(state.getPos(), state.get("psi"), data.robot_area, "robot_area", true);

        std::vector<double> angles;
        for (int k = 1; k < _solver->N; k++)
            angles.emplace_back(_solver->getOutput(k, "psi"));

        visualizeRectangularRobotArea(state.getPos(), state.get("psi"),
                                      CONFIG["robot"]["length"].as<double>(), CONFIG["robot"]["width"].as<double>(),
                                      "robot_rect_area", true);

        visualizeRobotAreaTrajectory(_output.trajectory, angles, data.robot_area, "robot_area_trajectory", true, 0.1);
        LOG_MARK("Planner::visualize Done");
    }

    // Jules: Dee heb je zelf toegevoegd om meer controle te kriijgen wanneer dynamische obstacles worden gepublished
    void Planner::visualizeObstaclePredictionsPlanner(const State &state, const RealTimeData &data, bool include_time)
    {
        if (!include_time)
        {
            visualizeObstaclePredictions(data.dynamic_obstacles, "obstacle_predictions", true, 0.8);
        }
        else
        {
            visualizeObstaclePredictionsWithTime(data.dynamic_obstacles, "obstacle_predictions", true, 0.8, _solver->dt);
        }
    }
    void Planner::saveData(State &state, RealTimeData &data)
    {
        if (!_is_data_ready)
            return;

        auto &data_saver = _experiment_util->getDataSaver();

        // Save planning data
        double planning_time = BENCHMARKERS.getBenchmarker("planning").getLast();
        data_saver.AddData("runtime_control_loop", planning_time);
        if (planning_time > 1. / CONFIG["control_frequency"].as<double>())
            LOG_WARN("Planning took too long: " << planning_time << " ms");
        data_saver.AddData("runtime_optimization", BENCHMARKERS.getBenchmarker("optimization").getLast());

        if (!_output.success)
            data_saver.AddData("status", 3.); // 3 and 2 for backward compatilibity
        else
            data_saver.AddData("status", 2.);

        for (auto &module : _modules)
            module->saveData(data_saver);

        _experiment_util->update(state, _solver, data);
    }

    void Planner::reset(State &state, RealTimeData &data, bool success)
    {
        if (CONFIG["recording"]["enable"].as<bool>())
            _experiment_util->onTaskComplete(success); // Save data

        _solver->reset(); // Reset the solver

        for (auto &module : _modules) // Reset modules
            module->reset();

        state = State(); // Reset the state
        data.reset();    // Reset the data
        _was_reset = true;
        _startup_timer->start();
    }

    bool Planner::isObjectiveReached(const State &state, const RealTimeData &data) const
    {
        bool objective_reached = true;
        for (auto &module : _modules)
            objective_reached = objective_reached && module->isObjectiveReached(state, data);
        return objective_reached;
    }
}