# Jackal Planner Implementation Discrepancy Analysis
## Real-World vs Simulator Implementations

**Document Version:** 1.0  
**Date:** 2025-11-20  
**Author:** AI Analysis  
**Purpose:** Identify and document all discrepancies between the real-world and simulator Jackal planner implementations to facilitate alignment.

---

## 1. Overview

### 1.1 File Descriptions

#### Real-World Implementation
- **File:** `mpc_planner_jackal/src/jules_ros1_real_jackalplanner.cpp`
- **Header:** `mpc_planner_jackal/include/mpc_planner_jackal/jules_ros1_real_jackalplanner.h`
- **Lines of Code:** 1,654
- **Purpose:** MPC-based motion planner for physical Clearpath Jackal UGV robots operating in real-world environments (e.g., laboratory with Vicon motion capture system)

#### Simulator Implementation
- **File:** `mpc_planner_jackalsimulator/src/jules_ros1_jackalplanner.cpp`
- **Header:** `mpc_planner_jackalsimulator/include/mpc_planner_jackalsimulator/jules_ros1_jackalplanner.h`
- **Lines of Code:** 1,561
- **Purpose:** MPC-based motion planner for simulated Jackal robots in Gazebo/RViz environments

### 1.2 Role in the Jackal System

Both planners serve as the primary decision-making nodes in a multi-robot coordination system. Their key responsibilities include:

1. **Trajectory Planning:** Computing collision-free, dynamically feasible trajectories using Model Predictive Control (MPC)
2. **Multi-Robot Coordination:** Sharing trajectory predictions with other robots and avoiding collisions
3. **Reference Path Tracking:** Following global paths generated by a higher-level roadmap planner
4. **Obstacle Avoidance:** Detecting and avoiding both static and dynamic obstacles
5. **State Management:** Managing robot lifecycle states (initialization, planning, goal reaching, resetting)

The planners integrate with:
- **Upstream:** Roadmap planner (reference paths), localization system (odometry/poses), perception (obstacles)
- **Downstream:** Low-level motion controller (velocity commands), visualization (RViz markers)
- **Peer-to-Peer:** Other robot planners (trajectory exchange for coordination)

---

## 2. High-Level Behavioral Differences

### 2.1 Platform-Specific Features

| Feature | Real-World | Simulator | Impact |
|---------|------------|-----------|--------|
| **Safety Mechanisms** | Multiple deadman switch options (Bluetooth controller, RQT interface, Jules controller) | None - always enabled | Real-world requires explicit human authorization; simulator trusts autonomous operation |
| **Hardware Integration** | Vicon motion capture for non-communicating obstacles (humans, dynamic objects) | Obstacle data from simulation aggregator only | Real-world can track arbitrary moving objects; simulator relies on pre-configured obstacles |
| **Benchmarking/Profiling** | RosTools::Benchmarker for loop timing, Instrumentor for session profiling | No performance profiling | Real-world emphasizes performance monitoring for hardware constraints |
| **Lab-Specific Constraints** | Hardcoded boundary limits (`x_min`, `x_max`, `y_min`, `y_max`) for lab area | No spatial boundaries | Real-world prevents robots from escaping physical workspace |

### 2.2 Operational Differences

| Aspect | Real-World | Simulator | Reason |
|--------|------------|-----------|--------|
| **Robot Footprint** | Single disc (simplified) | Multi-disc detailed footprint | Real robots use conservative single-disc; simulation can afford computational cost of detailed geometry |
| **Obstacle Handling** | Separates communicating robots from non-communicating objects (Vicon-tracked) | All obstacles treated uniformly | Real-world distinguishes between cooperative robots and unaware obstacles |
| **State Callback** | Uses measured velocity from odometry for braking | Uses velocity from state directly | Real-world prioritizes actual sensor data for safety-critical braking |
| **Goal Behavior** | Triggers roadmap reversal and rotation to goal orientation | Simple rotation without roadmap interaction | Real-world integrates tightly with experimental roadmap system |
| **Reset Mechanism** | Multi-stage reset with roadmap reversal signal | Gazebo world reset service available | Different simulation infrastructure |

### 2.3 Communication Strategy Differences

Both implementations support topology-based communication filtering, but apply it differently:

- **Real-World:** More conservative - always publishes during critical states, uses heartbeat mechanism
- **Simulator:** Stricter adherence to topology filtering logic

---

## 3. Detailed Discrepancy Tables

### 3.1 Initialization and Configuration

| Aspect | Real-World (`jules_ros1_real_jackalplanner.cpp`) | Simulator (`jules_ros1_jackalplanner.cpp`) | Impact/Notes |
|--------|--------------------------------------------------|---------------------------------------------|--------------|
| **Constructor Parameters** | `JulesRealJackalPlanner(ros::NodeHandle &nh)` | `JulesJackalPlanner(ros::NodeHandle &nh, ros::NodeHandle &pnh)` | Simulator uses private node handle for namespaced parameters |
| **Robot Footprint Initialization** | Single disc: `_data.robot_area = {MPCPlanner::Disc(0., config.robot_radius)}` | Multi-disc from config: `MPCPlanner::defineRobotArea(robot_length, robot_width, n_discs)` | Real uses simplified geometry for performance |
| **Non-Communicating Objects** | `initializeOtherRobotsAsObstaclesWithNonCom()` - adds Vicon-tracked humans/obstacles | Uses shared initializer only - no non-com objects | Real-world tracks additional dynamic obstacles beyond robots |
| **Platform-Specific Init** | `loadRealPlatformParameters()` loads deadman switch configs (`forward_x_experiment`, `rqt_dead_man_switch`, `jules_controller_deadman_switch`) | No platform-specific params | Real requires safety switch configuration |
| **Benchmarking Setup** | Creates `_benchmarker` and `RosTools::Instrumentor` session | No benchmarking infrastructure | Real monitors performance |
| **Startup Timer** | 10.0 seconds | 10.0 seconds | ✅ Same |
| **Control Frequency** | From config (typically 20 Hz) | Stored in member variable `_control_frequency` (20.0) | Same value, different storage approach |

### 3.2 ROS Communication Interfaces

#### 3.2.1 Subscribers

| Topic/Source | Real-World | Simulator | Queue Size | Message Type | Notes |
|--------------|------------|-----------|------------|--------------|-------|
| **State (Odometry)** | `/input/state` | `input/state` | 5 | `nav_msgs::Odometry` | Real uses absolute topic; sim uses relative |
| **State (Pose Alternative)** | ❌ Not subscribed | `input/state_pose` | 1 | `geometry_msgs::PoseStamped` | Simulator has alternative encoded pose topic |
| **Goal** | `/input/goal` | `input/goal` | 1 | `geometry_msgs::PoseStamped` | ✅ Functionally equivalent |
| **Reference Path** | `/input/reference_path` | `input/reference_path` | 1 | `nav_msgs::Path` | ✅ Functionally equivalent |
| **Obstacles** | `/input/obstacles` | `input/obstacles` | 1 | `derived_object_msgs::ObjectArray` (real) vs `mpc_planner_msgs::ObstacleArray` (sim) | **CRITICAL:** Different message types! |
| **Bluetooth Deadman** | `/input/bluetooth` | ❌ Not subscribed | 1 | `sensor_msgs::Joy` | Real-world only (safety) |
| **RQT Deadman** | `/jackal_deadman_switch` | ❌ Not subscribed | 1 | `geometry_msgs::Twist` | Real-world only (safety) |
| **Jules Controller** | `/joy` | ❌ Not subscribed | 1 | `sensor_msgs::Joy` | Real-world only (safety) |
| **All Robots Reached** | `/all_robots_reached_objective` | `/all_robots_reached_objective` | 1 | `std_msgs::Bool` | ✅ Same |
| **Other Robot Poses** | `<robot_ns>/robot_to_robot/output/pose` | `<robot_ns>/robot_to_robot/output/pose` | 1 | `geometry_msgs::PoseStamped` | ✅ Same |
| **Other Robot Trajectories** | `<robot_ns>/robot_to_robot/output/current_trajectory` | `<robot_ns>/robot_to_robot/output/current_trajectory` | 1 | `mpc_planner_msgs::ObstacleGMM` | ✅ Same |

#### 3.2.2 Publishers

| Topic | Real-World | Simulator | Queue Size | Message Type | Notes |
|-------|------------|-----------|------------|--------------|-------|
| **Velocity Command** | `/output/command` | `output/command` | 1 | `geometry_msgs::Twist` | ✅ Functionally equivalent |
| **Robot Pose** | `/output/pose` | `output/pose` | 1 | `geometry_msgs::PoseStamped` | ✅ Same |
| **Trajectory (Network)** | `/robot_to_robot/output/current_trajectory` | `robot_to_robot/output/current_trajectory` | 1 | `mpc_planner_msgs::ObstacleGMM` | ✅ Functionally equivalent |
| **Trajectory (Visualization)** | ❌ Not published | `output/current_trajectory` | 1 | `nav_msgs::Path` | Simulator publishes additional viz topic |
| **Objective Reached Event** | `/events/objective_reached` | `events/objective_reached` | 1 | `std_msgs::Bool` | ✅ Functionally equivalent |
| **Roadmap Reverse** | `/roadmap/reverse` | `roadmap/reverse` | 1 | `std_msgs::Empty` | ✅ Functionally equivalent |
| **Simulation Reset** | ❌ Not needed | `/lmpcc/reset_environment` | 1 | `std_msgs::Empty` | Simulator-specific |

#### 3.2.3 Service Clients

| Service | Real-World | Simulator | Service Type | Notes |
|---------|------------|-----------|--------------|-------|
| **Get Other Trajectories** | ❌ Not used | `/get_other_robot_obstacles_srv` | `mpc_planner_msgs::GetOtherTrajectories` | Simulator supports service-based trajectory queries (unused in current loop) |
| **Gazebo Reset** | ❌ Not applicable | `/gazebo/reset_world` | `std_srvs::Empty` | Simulator can reset Gazebo world |

### 3.3 Callback Implementations

| Callback | Real-World | Simulator | Key Differences |
|----------|------------|-----------|-----------------|
| **`stateCallback(Odometry)`** | Stores `_measured_velocity` from twist message | Calculates velocity with `std::hypot(vx, vy)` | Real caches velocity; sim computes magnitude |
| **`statePoseCallback(PoseStamped)`** | ❌ Does not exist | Handles encoded pose format (yaw in `orientation.z`, velocity in `position.z`) | Simulator has alternative state input |
| **`goalCallback(PoseStamped)`** | Sets goal + calls `_planner->onDataReceived(_data, "goal")` | Sets goal only (no planner notification) | Real notifies planner module of goal updates |
| **`pathCallback(Path)`** | Adds single `psi` value (0.0) to path | Adds `_state.get("psi")` for each pose | **Different:** Simulator preserves heading along path |
| **`obstacleCallback(...)`** | Processes `derived_object_msgs::ObjectArray` with Vicon ID-based filtering for non-communicating obstacles | Processes `mpc_planner_msgs::ObstacleArray` with Gaussian prediction handling | **CRITICAL:** Completely different obstacle processing pipelines |
| **`bluetoothCallback(Joy)`** | Updates `_enable_output` based on controller axis | ❌ Does not exist | Real-world safety mechanism |
| **`julesControllerCallback(Joy)`** | Alternative deadman switch handler | ❌ Does not exist | Real-world safety mechanism |
| **`rqtDeadManSwitchCallback(Twist)`** | RQT-based enable/disable | ❌ Does not exist | Real-world safety mechanism |
| **`poseOtherRobotCallback(...)`** | Empty implementation (does nothing) | Updates obstacle position/angle/speed from encoded pose | **Simulator actively uses pose updates** |
| **`trajectoryCallback(...)`** | Full implementation with validation, interpolation timestamp tracking | Same core logic | ✅ Very similar (timestamps use `ros::Time`) |
| **`allRobotsReachedObjectiveCallback(...)`** | Calls `reset()` method | Publishes roadmap reverse, clears data, restarts timer | Different reset implementations |

### 3.4 Main Control Loop

| Aspect | Real-World (`loop()`) | Simulator (`loopDirectTrajectoryStateMachine()`) | Differences |
|--------|------------------------|--------------------------------------------------|-------------|
| **Function Name** | `loop(const ros::TimerEvent &event)` | `loopDirectTrajectoryStateMachine(const ros::TimerEvent &event)` | Naming reflects architecture style |
| **Profiling** | `_benchmarker->start()` / `stop()` in active planning states | No profiling | Real monitors loop timing |
| **Logging** | `LOG_MARK("============= Loop =============")` | `LOG_DEBUG(...)` with obstacle counts | Different verbosity levels |
| **TIMER_STARTUP State** | Throttled logging every 4000ms | Throttled logging every 2000ms | Different throttle intervals |
| **WAITING_FOR_FIRST_EGO_POSE State** | Same logic | Same logic | ✅ Identical |
| **INITIALIZING_OBSTACLES State** | Calls `initializeOtherRobotsAsObstacles()` + visualizes | Same | ✅ Very similar |
| **WAITING_FOR_TRAJECTORY_DATA State** | Logs "WAITING_FOR_TRAJECTORY_DATA" with `LOG_DEBUG_THROTTLE(4000)` | Logs "INITIAL PLANNING" with `LOG_INFO` (no throttle) | Different log levels and messages |
| **PLANNING_ACTIVE State** | Checks `objectiveReached()` → transitions to `GOAL_REACHED` | Checks `objectiveReached()` → transitions to `JUST_REACHED_GOAL` | **Different state transition target** |
| **GOAL_REACHED State** | Handles roadmap reversal on first entry, then calls `rotateToGoal()` or `publishObjectiveReachedEvent()` | Applies braking, publishes objective | **Real has rotation logic; simulator just brakes** |
| **JUST_REACHED_GOAL State** | ❌ Does not exist | Applies braking → transitions to `GOAL_REACHED` | Simulator has intermediate braking state |
| **RESETTING State** | Updates `_previous_state` on first entry to prevent duplicate logging | Throttled logging only | Different state tracking |
| **Data Saving** | `saveDataStateBased()` - conditional based on state | Always saves if recording enabled | Real filters which states save data |

### 3.5 Planning and Command Generation

| Function/Feature | Real-World | Simulator | Key Differences |
|------------------|------------|-----------|-----------------|
| **`generatePlanningCommand()`** | Returns `std::pair<Twist, PlannerOutput>` | Returns `std::pair<Twist, PlannerOutput>` | ✅ Same signature |
| **WAITING_FOR_TRAJECTORY_DATA** | Logs "Waiting for first real trajectory data" (throttled 8000ms) | Logs "Waiting for first real trajectory data" (no throttle) | Different throttling |
| **PLANNING_ACTIVE** | Solves MPC → extracts `v` from solution index 1, `w` from index 0 | Same logic | ✅ Same |
| **GOAL_REACHED Handling** | Publishes reverse roadmap on first entry (state guard), then either stops or calls `rotateToGoal()` | Just applies braking | **Real integrates with roadmap system** |
| **JUST_REACHED_GOAL** | ❌ State doesn't exist | Applies braking scenario | Simulator has extra state |
| **Enable Output Check** | `if (_enable_output && output.success)` sets commands | `if (_enable_output && output.success)` sets commands | ✅ Same |
| **Velocity Command Assignment** | `cmd.linear.x = _planner->getSolution(1, "v")` | Same | ✅ Same |
| **Angular Command Assignment** | `cmd.angular.z = _planner->getSolution(0, "w")` | Same | ✅ Same |
| **State Velocity Update** | `_state.set("v", cmd.linear.x)` when enabled, `_state.set("v", _measured_velocity)` when disabled | No state velocity update in command generation | Real updates state from command |
| **Braking Command** | Uses `_measured_velocity` as current velocity | Uses `_state.get("v")` as current velocity | **Different velocity sources for braking** |

### 3.6 Multi-Robot Coordination

| Feature | Real-World | Simulator | Differences |
|---------|------------|-----------|-------------|
| **Robot Obstacle Initialization** | `initializeOtherRobotsAsObstaclesWithNonCom()` - custom method that adds both communicating robots AND non-communicating Vicon objects | `initializeOtherRobotsAsObstacles()` - standard method for communicating robots only | Real handles heterogeneous obstacle types |
| **Non-Communicating Objects** | Extracted from `_robot_ns_list` with `extractIdentifierIndicesNonComObj()`, initialized at `(100, 100)` with `obstacle_radius` | None | Real-world tracks humans/non-cooperative obstacles |
| **Obstacle Update (obstacleCallback)** | Filters by `object.id < _robot_ns_list.size()` to separate robots from non-com objects, updates non-com obstacle positions/predictions from Vicon | Clears and rebuilds `_data.dynamic_obstacles` from scratch each callback | **Fundamentally different obstacle management** |
| **Trajectory Interpolation** | `interpolateTrajectoryPredictionsByTime()` - full implementation | `interpolateTrajectoryPredictionsByTime()` - full implementation | ✅ Same logic (both use `ros::Time`) |
| **Validated Robots Tracking** | `_validated_trajectory_robots` set | `_validated_trajectory_robots` set | ✅ Same |
| **Trajectory Data Structure** | `_data.trajectory_dynamic_obstacles` map | `_data.trajectory_dynamic_obstacles` map | ✅ Same |

### 3.7 Communication Decision Logic

| Aspect | Real-World | Simulator | Differences |
|--------|------------|-----------|-------------|
| **Communication Filtering Config** | `_communicate_on_topology_switch_only` flag | `_communicate_on_topology_switch_only` flag | ✅ Same |
| **`publishCmdAndVisualize()`** | Calls helper functions: `decideCommunication()`, `recordCommunicationDecision()`, `logCommunicationDecision()` | Inline logic with similar checks | Real has cleaner separation of concerns |
| **Topology-Based Logic** | `shouldCommunicate()` method with state filtering + topology + heartbeat logic | Inline version in `publishCmdAndVisualize()` | Same logic, different organization |
| **Heartbeat Mechanism** | `shouldCommunicateBasedOnElapsedTime()` - publishes every 1.0 second when no topology change | Inline time-based check | Same functionality |
| **State Filtering** | Doesn't communicate in: `UNINITIALIZED`, `TIMER_STARTUP`, `WAITING_FOR_FIRST_EGO_POSE`, `INITIALIZING_OBSTACLES`, `GOAL_REACHED`, `RESETTING`, `ERROR_STATE` | Inline checks for same states | ✅ Same states filtered |
| **Non-Guided Topology Handling** | Computes `non_guided_topology_id = 2 * n_paths`, always communicates in non-guided mode | Same logic | ✅ Same |
| **Data Recording** | Records `publish_cmd_called`, `communicated`, stores in `_data.communicated_trajectory` | Records `tx_trajectory`, `tx_num_poses` | Different metrics tracked |
| **Trajectory Timestamp** | Updates `_data.last_send_trajectory_time = ros::Time::now()` on publish | No timestamp tracking | Real tracks last send time for heartbeat |

### 3.8 Visualization and Publishing

| Feature | Real-World | Simulator | Differences |
|---------|------------|-----------|-------------|
| **`publishDirectTrajectory()`** | Publishes `mpc_planner_msgs::ObstacleGMM`, records `tx_trajectory` + `tx_num_poses` | Publishes same message, records `tx_trajectory` only | Real tracks more metrics |
| **`publishCurrentTrajectory()`** | ❌ Does not exist | Publishes `nav_msgs::Path` for visualization | Simulator has dedicated viz publisher |
| **`visualize()`** | Publishes lab boundary limits + goal marker | Publishes robot heading angle as line | Different visualization content |
| **Planner Visualization Calls** | `_planner->visualizeObstaclePredictionsPlanner(_state, _data, true)` | `_planner->visualizeObstaclePredictionsPlanner(_state, _data, false)` | Different boolean parameter (true vs false) |
| **Pose Publishing** | Only via trajectory messages | Also has `publishEgoPose()` method | Simulator publishes standalone poses |

### 3.9 Reset and Goal Handling

| Feature | Real-World | Simulator | Differences |
|---------|------------|-----------|-------------|
| **`reset()` Method** | Calls `_planner->reset(_state, _data, true)`, clears validated robots and trajectory obstacles, sets 4.0s startup timer | Publishes reverse roadmap, same cleanup, sets 4.0s timer | Real-world comments out roadmap reversal in reset (legacy) |
| **`objectiveReached()` Method** | Checks lab boundaries (`x_max`, `y_max`, `x_min`, `y_min`) based on `_forward_x_experiment` flag, toggles direction | Calls `_planner->isObjectiveReached(_state, _data)` | **Completely different:** Real uses spatial limits; simulator uses planner's goal tolerance |
| **`rotateToGoal()` / `rotatePiRadiansCw()`** | Rotates to face goal point using `atan2(goal - position)` | Rotates π radians clockwise from reference path heading | **Different rotation strategies** |
| **Goal Reached Behavior** | Publishes roadmap reverse message, rotates to goal, then publishes objective | Applies braking, publishes objective | Real integrates with roadmap reversal |

### 3.10 Error Handling and Safety

| Feature | Real-World | Simulator | Differences |
|---------|------------|-----------|-------------|
| **Deadman Switch** | Three mechanisms (Bluetooth, RQT, Jules controller), `_enable_output` defaults to `false` | No deadman switches, `_enable_output` defaults to `true` | **Critical safety difference** |
| **Flip Detection** | In `stateCallback()` - checks quaternion x/y components | In both `stateCallback()` and `statePoseCallback()` | Simulator has redundant flip checks |
| **Invalid State Handling** | Logs error but continues | Logs error but continues | ✅ Same |
| **Obstacle Callback Guards** | State-based early returns with switch statement | Early return if `!_have_received_meaningful_trajectory_data` | Different guards |
| **Trajectory Validation** | Checks: obstacle exists, message valid, ID match, before processing | Same checks | ✅ Same |

### 3.11 Member Variables

| Variable | Real-World | Simulator | Notes |
|----------|------------|-----------|-------|
| `_benchmarker` | `std::unique_ptr<RosTools::Benchmarker>` | ❌ Not present | Real-world performance monitoring |
| `_measured_velocity` | `double` (cached from odometry) | ❌ Not present | Real caches sensor velocity |
| `_forward_x_experiment` | `bool` (lab experiment config) | ❌ Not present | Real-world experiment flag |
| `_rqt_dead_man_switch` | `bool` | ❌ Not present | Real-world safety |
| `_jules_controller_deadman_switch` | `bool` | ❌ Not present | Real-world safety |
| `_num_non_com_obj` | `int` | ❌ Not present (member exists in config but not used) | Real tracks non-communicating obstacles |
| `x_min`, `x_max`, `y_min`, `y_max` | Hardcoded lab boundaries | ❌ Not present | Real-world spatial limits |
| `_control_frequency` | ❌ Not stored | `double` member variable | Simulator stores frequency |
| `_infeasible_deceleration` | ❌ Not stored | `double` member variable | Simulator stores deceleration |
| `_goal_received` | ❌ Not present | `bool` flag | Simulator tracks goal state |
| `_goal_xy` | ❌ Not present | `Eigen::Vector2d` | Simulator caches goal |
| `_received_obstacle_callback_first_time` | ❌ Not present | `bool` flag | Simulator tracks first callback |
| `_have_received_meaningful_trajectory_data` | ❌ Not present | `bool` flag | Simulator gates obstacle processing |
| `_immediate_robot_robot_communication` | ❌ Not present | `bool` flag (unused) | Simulator config option |

### 3.12 Helper Methods Unique to Each Implementation

#### Real-World Only
- `loadRealPlatformParameters()` - Loads experiment and safety switch configs
- `initializeOtherRobotsAsObstaclesWithNonCom()` - Adds non-communicating Vicon objects
- `initializeRealHardwareComponents()` - Sets up benchmarker and profiling
- `bluetoothCallback()` - Bluetooth controller safety
- `julesControllerCallback()` - Jules controller safety
- `rqtDeadManSwitchCallback()` - RQT interface safety
- `decideCommunication()` - Helper for communication decision
- `recordCommunicationDecision()` - Helper for data recording
- `logCommunicationDecision()` - Helper for logging
- `topologyTriggersCommunication()` - Detailed topology analysis
- `shouldCommunicateBasedOnElapsedTime()` - Heartbeat logic
- `saveDataStateBased()` - Conditional data saving by state

#### Simulator Only
- `initializeSimulatorComponents()` - Minimal simulator setup
- `statePoseCallback()` - Encoded pose format handling
- `obstacleServiceCallback()` - Service-based obstacle input (unused)
- `publishCurrentTrajectory()` - Visualization-specific publisher
- `publishEgoPose()` - Standalone pose publishing
- `rotatePiRadiansCw()` - Fixed π rotation at goal
- `logDataState()` - Debug utility for data state

---

## 4. Critical Discrepancies Requiring Alignment

### 4.1 Obstacle Message Types and Processing
**Priority: CRITICAL**

The two implementations use **completely different obstacle message types** and processing pipelines:

- **Real:** `derived_object_msgs::ObjectArray` with Vicon-based IDs, separates robots from non-communicating objects
- **Simulator:** `mpc_planner_msgs::ObstacleArray` with Gaussian predictions

**Impact:** Cannot share obstacle data directly; fundamentally different perception interfaces.

**Recommendation:** 
- If aligning to real-world: Simulator needs to support `derived_object_msgs::ObjectArray` and implement Vicon-style ID filtering
- If aligning to simulator: Real-world needs obstacle aggregator to convert Vicon data to `mpc_planner_msgs::ObstacleArray` with predictions

### 4.2 Deadman Switch Safety Mechanisms
**Priority: HIGH (Safety)**

Real-world requires explicit human authorization via deadman switches; simulator has no safety interlocks.

**Recommendation:** Add simulator config option to enable/disable deadman requirement for easier testing, but align production behavior to real-world safety model.

### 4.3 Robot Footprint Representation
**Priority: MEDIUM**

- **Real:** Single disc (conservative, fast)
- **Simulator:** Multi-disc detailed footprint (accurate, slower)

**Impact:** Different collision checking accuracy and computational cost.

**Recommendation:** Make footprint configurable; real-world may benefit from multi-disc if computation allows.

### 4.4 Goal Reached Detection
**Priority: MEDIUM**

- **Real:** Spatial boundary crossing (`x_max`, `y_max`)
- **Simulator:** Planner's goal tolerance check

**Impact:** Different experiment behaviors and reset triggers.

**Recommendation:** Align to simulator's goal tolerance approach (more general), remove hardcoded boundaries.

### 4.5 State Machine Differences
**Priority: MEDIUM**

- **Real:** Direct transition `PLANNING_ACTIVE` → `GOAL_REACHED`
- **Simulator:** Intermediate state `PLANNING_ACTIVE` → `JUST_REACHED_GOAL` → `GOAL_REACHED`

**Impact:** Different braking behavior at goal.

**Recommendation:** Adopt simulator's intermediate braking state for smoother stops.

### 4.6 Communication Decision Logic Organization
**Priority: LOW (Refactoring)**

Real-world has cleaner separation with helper methods; simulator has inline logic.

**Impact:** Code maintainability only.

**Recommendation:** Refactor simulator to match real-world's helper method structure.

---

## 5. Alignment Recommendations

### 5.1 Short-Term (Quick Wins)
1. **Standardize state machine:** Add `JUST_REACHED_GOAL` to real-world
2. **Unify communication helpers:** Refactor simulator to use helper methods
3. **Add simulator config flags:** Make deadman switches configurable (disabled by default in sim)
4. **Align logging levels:** Standardize log messages and throttle intervals

### 5.2 Medium-Term (Architectural)
1. **Obstacle interface:** Create obstacle adapter layer to support both message types
2. **Make footprint configurable:** Support single-disc and multi-disc modes via config
3. **Unify goal detection:** Remove hardcoded boundaries from real-world, use planner tolerance
4. **Merge rotation logic:** Consolidate `rotateToGoal()` and `rotatePiRadiansCw()` into single method

### 5.3 Long-Term (Full Alignment)
1. **Shared base class:** Extract common functionality into `JackalPlannerBase`
2. **Platform adapters:** Platform-specific code in derived classes
3. **Unified testing:** Single test suite that works for both platforms
4. **Configuration-driven behavior:** Minimize code differences, maximize config-driven specialization

---

## 6. Dependency Analysis

### 6.1 Shared Dependencies
Both implementations depend on:
- `JackalPlanner::JackalPlannerInitializer` - Common initialization utilities
- `MPCPlanner::Planner` - Core MPC planning engine
- `MPCPlanner::RealTimeData` - Data structures
- `MPCPlanner::State` - Robot state representation
- `ros_tools` - Logging, visualization, conversions, math utilities
- `mpc_planner_util` - Multi-robot utilities, parameters, YAML loading

### 6.2 Unique Dependencies

**Real-World Only:**
- `derived_object_msgs::ObjectArray` - Vicon obstacle messages
- `RosTools::Benchmarker` - Performance profiling
- `RosTools::Instrumentor` - Session profiling

**Simulator Only:**
- `mpc_planner_msgs::GetOtherTrajectories` - Service-based trajectory queries (unused)
- `std_srvs::Empty` - Gazebo reset service
- Gazebo/simulation infrastructure

---

## 7. Testing Recommendations

To validate alignment:

1. **Unit Tests:**
   - Test communication decision logic with identical topology scenarios
   - Test obstacle filtering with same input data (after interface unification)
   - Test state machine transitions

2. **Integration Tests:**
   - Run same reference path in both systems, compare trajectories
   - Multi-robot coordination scenarios with identical initial conditions
   - Goal reaching and reset behavior

3. **Performance Tests:**
   - Compare loop timing (real vs sim)
   - Memory usage with varying obstacle counts
   - Network bandwidth with/without topology filtering

---

## 8. Migration Checklist

When bringing simulator in line with real-world behavior:

- [ ] Add support for `derived_object_msgs::ObjectArray` or create adapter
- [ ] Implement non-communicating obstacle tracking (Vicon-style)
- [ ] Add `JUST_REACHED_GOAL` state to real-world (already in simulator)
- [ ] Make robot footprint configurable (single-disc vs multi-disc)
- [ ] Remove hardcoded lab boundaries from real-world
- [ ] Unify goal tolerance checking using planner method
- [ ] Add deadman switch config option to simulator (disabled by default)
- [ ] Standardize logging messages and throttle intervals
- [ ] Extract communication decision helpers in simulator
- [ ] Add `_measured_velocity` caching to simulator for consistent braking
- [ ] Unify rotation methods (`rotateToGoal` vs `rotatePiRadiansCw`)
- [ ] Merge roadmap reversal logic (simulator publishes, real comments it out)
- [ ] Standardize data recording metrics
- [ ] Add benchmarking infrastructure to simulator (optional, config-gated)

---

## 9. Conclusion

The real-world and simulator implementations share a strong common foundation but have diverged in several key areas:

**Major Differences:**
1. Obstacle message types and processing (CRITICAL)
2. Safety mechanisms (deadman switches)
3. Robot footprint modeling
4. Goal detection logic
5. State machine details

**Alignment Strategy:**
- **Keep:** Multi-robot coordination, trajectory interpolation, MPC integration (already aligned)
- **Unify:** State machine, communication logic, goal detection, rotation behavior
- **Make Configurable:** Footprint model, deadman switches, benchmarking
- **Adapt:** Obstacle interface layer to support both Vicon and aggregator inputs

The simulator implementation is generally cleaner and more modular (e.g., separate pose callback, cleaner state machine). The real-world implementation has critical safety features and handles heterogeneous obstacles. The ideal aligned version would combine the best of both: simulator's clean architecture + real-world's safety and obstacle handling capabilities.
